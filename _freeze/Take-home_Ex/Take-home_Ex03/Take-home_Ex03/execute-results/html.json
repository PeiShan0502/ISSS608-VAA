{
  "hash": "00d09500447a5b69e7367013080696de",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 3\"\nauthor: Kwok Pei Shan\ndate: \"May 22, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n## Getting Started\n\nThe code chunk below loads the necessary R packages for this take-home exercise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(jsonlite, tidygraph, ggraph,\n               visNetwork, graphlayouts, ggforce,\n               skimr, tidytext, tidyverse)\n```\n:::\n\n\n## Importing Graph Data\n\nIn the code chunk below, `fromJSON()` of **jsonlite** package is used to import *MC3.json* into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_data <- fromJSON(\"data/mc3_cleaned.json\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mc3_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nmc3 data is a directed multigraph with nodes and links. As shown by the output of the code chunk above, they are stored as lists instead of vector columns.\n\n## **Wrangling and tidying edges**\n\n### **Extracting edges**\n\nThe code chunk below will be used to extract the links data frame of mc3_data and save it as a tibble data frame called mc3_edges:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- as_tibble(mc3_data$links) %>%\n  distinct() %>%\n  mutate(source = as.character(source),\n         target = as.character(target),\n         type = as.character(type)) %>%\n  group_by(source, target, type) %>%\n  filter(source != target) %>%\n  ungroup()\n```\n:::\n\n\n::: callout-note\n-   `distinct()` is used to ensure that there will be no duplicated records.\n\n-   `mutate()` and `as.character()` are used to convert the field data type from list to character.\n\n-   the `filter(source != target)` is to ensure that no record with similar source and target.\n:::\n\nNext, `glimpse()` of dplyr will be used to reveal the structure of *mc3_edges* tibble data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 75,817\nColumns: 11\n$ start_date          <chr> \"2016-10-29T00:00:00\", \"2035-06-03T00:00:00\", \"202…\n$ type                <chr> \"Event.Owns.Shareholdership\", \"Event.Owns.Sharehol…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Niklaus Oberon\", \"Pela…\n$ `_last_edited_date` <chr> \"2035-01-01T00:00:00\", \"2035-07-15T00:00:00\", \"203…\n$ `_date_added`       <chr> \"2035-01-01T00:00:00\", \"2035-07-15T00:00:00\", \"203…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Oceanus Corp…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Manual Entry\", \"Automatic Imp…\n$ source              <chr> \"Avery Inc\", \"Berger-Hayes\", \"Bowers Group\", \"Bowm…\n$ target              <chr> \"Allen, Nichols and Thompson\", \"Jensen, Morris and…\n$ key                 <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ end_date            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n```\n:::\n:::\n\n\n::: callout-note\nFrom the table above, the following data issues can be identified:\n\n-   `start_date`, `_last_edited_date`, `_date_added` ,and `end_date` should be in date data type. Currently they are in character data type.\n\n-   Some field names start with \"`_`\", they need to be renamed in order to avoid unnecessary coding issue in the later tasks.\n:::\n\n### **Correcting date data type in `mc3_edges`**\n\nIn the code chunk below, `as_datetime()` of **lubridate** package is used to convert fields with character date into **POSIXt** format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges$start_date <- as_datetime(mc3_edges$start_date)\nmc3_edges$`_last_edited_date`<- as_datetime(mc3_edges$`_last_edited_date`)\nmc3_edges$`_date_added`<- as_datetime(mc3_edges$`_date_added`)\nmc3_edges$end_date <- as_datetime(mc3_edges$end_date)\n```\n:::\n\n\n### **Changing field names in `mc3_edges`**\n\nIn the code chunk below, `rename()` of **dplyr** package is used to change the following fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- mc3_edges %>%\n  rename(\"last_edited_by\" = \"_last_edited_by\",\n         \"last_edited_date\" = \"_last_edited_date\",\n         \"date_added\" = \"_date_added\",\n         \"raw_source\" = \"_raw_source\",\n         \"algorithm\" = \"_algorithm\")\n```\n:::\n\n\nWe further examine the edges, particularly the *type* field, and we can see that most of the edges are either Shareholdership or BeneficialOwnership. FamilyRelationship has the least of all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc3_edges, aes(x = type)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nWe remove some columns in mc3_edges that won't be needed for this analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges1 <- subset(mc3_edges, select = -c(last_edited_by, last_edited_date, date_added, raw_source, algorithm, key))\n```\n:::\n\n\n## **Wrangling and tidying nodes**\n\n### **Extracting nodes**\n\nThe code chunk below will be used to extract the *nodes* data.frame of *mc3_data* and parses it as a tibble data.frame called *mc3_nodes*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes <- as_tibble(mc3_data$nodes) %>%\n  distinct() %>%\n  mutate(country = as.character(country),\n         id = as.character(id), \n         ProductServices = as.character(ProductServices),\n         type = as.character(type))\n```\n:::\n\n\nNext, the code chunk below is used to reveal the data structure of *mc3_nodes* tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 60,520\nColumns: 15\n$ type                <chr> \"Entity.Organization.Company\", \"Entity.Organizatio…\n$ country             <chr> \"Uziland\", \"Mawalara\", \"Uzifrica\", \"Islavaragon\", …\n$ ProductServices     <chr> \"Unknown\", \"Furniture and home accessories\", \"Food…\n$ PointOfContact      <chr> \"Rebecca Lewis\", \"Michael Lopez\", \"Steven Robertso…\n$ HeadOfOrg           <chr> \"Émilie-Susan Benoit\", \"Honoré Lemoine\", \"Jules La…\n$ founding_date       <chr> \"1954-04-24T00:00:00\", \"2009-06-12T00:00:00\", \"202…\n$ revenue             <dbl> 5994.73, 71766.67, 0.00, 0.00, 4746.67, 46566.67, …\n$ TradeDescription    <chr> \"Unknown\", \"Abbott-Gomez is a leading manufacturer…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Pelagia Alethea Mordoc…\n$ `_last_edited_date` <chr> \"2035-01-01T00:00:00\", \"2035-01-01T00:00:00\", \"203…\n$ `_date_added`       <chr> \"2035-01-01T00:00:00\", \"2035-01-01T00:00:00\", \"203…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Existing Cor…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Automatic Import\", \"Automatic…\n$ id                  <chr> \"Abbott, Mcbride and Edwards\", \"Abbott-Gomez\", \"Ab…\n$ dob                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n```\n:::\n:::\n\n\n::: callout-note\nFrom the above output:\n\n-   `founding_date`, `_last_edited_date` , `_date_added` , `dob` should be in the date data type, currently it's character data type.\n\n-   Some field names start with \"`_`\", they need to be renamed in order to avoid unnecessary coding issue in the later tasks.\n:::\n\n### **Correcting date data type in `mc3_nodes`**\n\nIn the code chunk below, `as_datetime()` of **lubridate** package is used to convert fields with character date into **POSIXt** format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes$founding_date <- as_datetime(mc3_nodes$founding_date)\nmc3_nodes$`_last_edited_date`<- as_datetime(mc3_nodes$`_last_edited_date`)\nmc3_nodes$`_date_added`<- as_datetime(mc3_nodes$`_date_added`)\nmc3_nodes$dob <- as_datetime(mc3_nodes$dob)\n```\n:::\n\n\n### **Changing field names in `mc3_nodes`**\n\nIn the code chunk below, `rename()` of **dplyr** package is used to change the following fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes<- mc3_nodes %>%\n  rename(\"last_edited_by\" = \"_last_edited_by\",\n         \"last_edited_date\" = \"_last_edited_date\",\n         \"date_added\" = \"_date_added\",\n         \"raw_source\" = \"_raw_source\",\n         \"algorithm\" = \"_algorithm\")\n```\n:::\n\n\nFurthermore, in case there are some nodes featured in the edges but not in the nodes from the mc3 list object. For consistency, we will combine both sets of nodes to give the complete nodes df.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract all nodes from edges\nid1 <- mc3_edges %>%\n  select(source) %>%\n  rename(id = source)\n\nid2 <- mc3_edges %>%\n  select(target) %>%\n  rename(id = target)\n\nadditional_nodes <- rbind(id1, id2) %>%\n  distinct() %>%\n  filter(!id %in% mc3_nodes[[\"id\"]])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#combine all nodes\nmc3_nodes1 <- rbind(mc3_nodes, additional_nodes) %>%\n  distinct()\n```\n:::\n\n\nWe further examine the nodes below, particularly the *type* field, and we can see that most of the nodes are persons (51,649 nodes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc3_nodes1, aes(x = type)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## **Check for duplicate nodes**\n\nThe output of the code chunk below confirms that there are no duplicated nodes with the same id:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes1[duplicated(mc3_nodes1$id), ] %>%\n  arrange(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 15\n# ℹ 15 variables: type <chr>, country <chr>, ProductServices <chr>,\n#   PointOfContact <chr>, HeadOfOrg <chr>, founding_date <dttm>, revenue <dbl>,\n#   TradeDescription <chr>, last_edited_by <chr>, last_edited_date <dttm>,\n#   date_added <dttm>, raw_source <chr>, algorithm <chr>, id <chr>, dob <dttm>\n```\n:::\n:::\n\n\n## **Cleaning up ProductServices in nodes**\n\nWe note that only nodes of type Organisation have meaningful description for ProductServices, and for nodes of type Person, the ProductServices field has missing values. The same can be said for the following fields: PointOfContact, HeadOfOrg, founding_date, revenue, TradeDescription.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$ProductServices)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51649\n```\n:::\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$PointOfContact)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51665\n```\n:::\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$HeadOfOrg)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51649\n```\n:::\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$founding_date)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51649\n```\n:::\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$revenue)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51665\n```\n:::\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_nodes1$TradeDescription)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51649\n```\n:::\n:::\n\n\nThe above output also shows that PointOfContact and revenue seems to also be missing for some organisations.\n\nFor this reason, we will only use the ProductServices column for nodes that are organisations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract type that contains \"Entity.Organization\"\norg_nodes <- mc3_nodes1 %>%\n  filter(str_detect(type, \"Entity.Organization\"))\n\n# extract type that contains \"Entity.Person\"\nperson_nodes <- mc3_nodes1 %>%\n  filter(str_detect(type, \"Entity.Person\"))\n\n# Person_nodes that have meaningful ProductServices\nperson_nodes_w_pdt_services <- person_nodes %>%\n  filter(ProductServices != 'character(0)' & !is.na(ProductServices))\n\nprint(paste0(\"Person nodes with ProductServices not null: \", length(person_nodes_w_pdt_services$id)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Person nodes with ProductServices not null: 0\"\n```\n:::\n:::\n\n\n## **Simplifying ProductServices in nodes**\n\nAs our priority are the fishing-related companies, we will focus on nodes where the type is \"Entity.Organization.FishingCompany\" (600 nodes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simplify ProductServices\norg_nodes_fishing <- org_nodes %>%\n  filter(type == \"Entity.Organization.FishingCompany\")\n```\n:::\n\n\nSince fishing company will not have date of birth (dob), we also remove the dob field from org_nodes_fishing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\norg_nodes_fishing <- subset(org_nodes_fishing, select = -dob)\n\n#Check for missing values:\nprint(sum(is.na(org_nodes_fishing)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Data Visualisations\n\n### **Task 2 - Atypical Business Transactions**\n\nWe are going to attempt Task 2:\n\n|                                                                                                                                                                                                         |\n|------------------------------------------------------------------------|\n| Using your visualizations, find and display examples of typical and atypical business transactions (e.g., mergers, acquisitions, etc.). Can you infer the motivations behind changes in their activity? |\n\nFor this task, as we are looking at business transactions such as mergers or acquisitions, etc., we are planning to look at the edges which represent Beneficial Ownership or Shareholdership, and also look into the *start_date* and *end_date* to examine which business transactions are typical and atypical. The idea is to visualize the type of event using the weight of the edges, e.g., Beneficial Ownership may have higher weightage than Shareholdership, and hence appear as a thicker line on the network graph. And use the *start_date* and *end_date* to see the changes in the network graph over time.\n\nThe steps are as follows:\n\n1.  In mc3_edges tibble data frame, include weight factor such that Beneficial Ownership has higher weight than Shareholdership. In particular, Beneficial Ownership, Shareholdership, FamilyRelationship, and Works.For will have weightage of 4, 3, 2, and 1 respectively (assuming this is the level of importance of the types of edges)\n2.  put both edges and nodes together to construct network graph\n3.  Build graph visualisation\n4.  Add interactivity (slider) to show changes in network graph over time, using *start_date* and *end_date*. Also add tooltip to be able to see entities which are connected to SouthSeafood Express Corp.\n\n[Step 1:]{.underline}\n\n-   In mc3_edges tibble data frame, include weight factor such that Beneficial Ownership, Shareholdership, FamilyRelationship, and Works.For will have weightage of 4, 3, 2, and 1 respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges$weight <- ifelse(mc3_edges$type == \"Relationship.FamilyRelationship\", 2, ifelse(mc3_edges$type == \"Event.WorksFor\", 1, \n                                                                                          ifelse(mc3_edges$type == \"Event.Owns.BeneficialOwnership\", 4,\n                                                                                                 ifelse(mc3_edges$type == \"Event.Owns.Shareholdership\", 3, \"Not Applicable\"))))\n```\n:::\n\n\nSince there won't be any edges that fall under \"Not Applicable\" weight, we can change data type of the weight factor from character to integer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges$weight <- as.numeric(mc3_edges$weight)\n```\n:::\n\n\n[Step 2:]{.underline}\n\nBefore we put both edges and nodes together to construct network graph, we first need to remove missing values in `mc3_edges1`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(sum(is.na(mc3_edges1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 75559\n```\n:::\n:::\n\n\nUpon closer observation, it seems that the missing values come from the *end_date* column. The end_date column contains NA values for Relationship.FamilyRelationship edges, and when the event has not yet ended for Event.Owns.BeneficialOwnership, Event.Owns.Shareholdership, and Event.WorksFor edges.\n\nTo analyse atypical business transactions, we want to look more closely into transactions where end_date of a transaction may be the same as the start_date of another transaction. Such a transaction looks fishy and may suggest that something illegal is going on. An example is shown below, where AguaLeska Transit N.V. relinquished shareholdership of SouthSeafood Express Corp on the same day that Tainamarine Fishing Co. assumed shareholdership of SouthSeafood Express Corp:\n\n![](images/clipboard-1704811638.png)\n\nFor the above purpose, we can remove rows where the end_date is NA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges2 <- mc3_edges1[!is.na(mc3_edges1$end_date), ]\n\n#Check for missing values:\nprint(sum(is.na(mc3_edges2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nWe construct the network graph with the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_graph <- tbl_graph(nodes = org_nodes_fishing,\n                       edges = mc3_edges2,\n                       directed = FALSE) %>%\n  mutate(betweenness_centrality = \n           centrality_betweenness(),\n         closeness_centrality = \n           centrality_closeness())\n```\n:::\n\n\n[Step 3:]{.underline}\n\n-   Build graph visualisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_graph %>%\n  filter(betweenness_centrality >= 300000) %>%\nggraph(layout = \"fr\") +\n  geom_edge_link(aes(alpha = 0.5)) +\n  geom_node_point(aes(\n    size = betweenness_centrality,\n    colors = \"lightblue\",\n    alpha = 0.5)) +\n  scale_size_continuous(range = c(1,10)) +\n  theme_graph()\n```\n:::\n\n\n### **Task 3**\n\nNext, we are going to attempt Task 3:\n\n|                                                                                                                                                                           |\n|------------------------------------------------------------------------|\n| Develop a visual approach to examine inferences. Infer how the influence of a company changes through time. Can you infer ownership or influence that a network may have? |\n\nFor this task, we are planning to use centrality measures such as betweenness centrality and closeness centrality to measure the influence of a company. The higher the betweenness centrality of a company, the more important the company is in acting as a “bridge” to manage relationships and business transactions between other companies, which suggests that this company has high influence over others as it is highly crucial in facilitating flow of information and/or resources between other companies. Similarly, a company with high closeness centrality suggests that this company has high influence as they are close to many other companies and thus, able to efficiently communicate and spread information quickly.\n\nAt the moment, the idea is to have a visualization that looks like [this](https://r4va.netlify.app/chap27#modifying-network-nodes), where the bigger the size of a node, the higher the betweenness/ closeness centrality of the company (i.e., the more influence a company has), with perhaps a slider to measure any changes in the influential companies over time.\n",
    "supporting": [
      "Take-home_Ex03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
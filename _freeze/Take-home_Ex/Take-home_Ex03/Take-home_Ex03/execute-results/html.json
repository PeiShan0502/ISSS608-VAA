{
  "hash": "3c0f82b0b4b021a24acb9a2a4c5930b1",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 3\"\nauthor: Kwok Pei Shan\ndate: \"May 22, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n## Getting Started\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(jsonlite, tidygraph, ggraph,\n               visNetwork, graphlayouts, ggforce,\n               skimr, tidytext, tidyverse)\n```\n:::\n\n\n## Importing Graph Data\n\nIn the code chunk below, `fromJSON()` of **jsonlite** package is used to import *MC3.json* into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_data <- fromJSON(\"data/mc3_cleaned.json\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mc3_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nmc3 data is a directed multigraph with nodes and links. As shown by the output of the code chunk above, they are stored as lists instead of vector columns.\n\n## **Wrangling and tidying edges**\n\n### **Extracting edges**\n\nThe code chunk below will be used to extract the links data frame of mc3_data and save it as a tibble data frame called mc3_edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- as_tibble(mc3_data$links) %>%\n  distinct()\n```\n:::\n\n\nNext, `glimpse()` of dplyr will be used to reveal the structure of *mc3_edges* tibble data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 75,817\nColumns: 11\n$ start_date          <chr> \"2016-10-29T00:00:00\", \"2035-06-03T00:00:00\", \"202…\n$ type                <chr> \"Event.Owns.Shareholdership\", \"Event.Owns.Sharehol…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Niklaus Oberon\", \"Pela…\n$ `_last_edited_date` <chr> \"2035-01-01T00:00:00\", \"2035-07-15T00:00:00\", \"203…\n$ `_date_added`       <chr> \"2035-01-01T00:00:00\", \"2035-07-15T00:00:00\", \"203…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Oceanus Corp…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Manual Entry\", \"Automatic Imp…\n$ source              <chr> \"Avery Inc\", \"Berger-Hayes\", \"Bowers Group\", \"Bowm…\n$ target              <chr> \"Allen, Nichols and Thompson\", \"Jensen, Morris and…\n$ key                 <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ end_date            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n```\n:::\n:::\n\n\n::: callout-note\nFrom the table above, the following data issues can be identified:\n\n-   `start_date`, `_last_edited_date`, `_date_added` ,and `end_date` should be in date data type. Currently they are in character data type.\n\n-   Some field names start with \"\\_\", they need to be renamed in order to avoid unnecessary coding issue in the later tasks.\n:::\n\n### **Correcting date data type in `mc3_edges`**\n\nIn the code chunk below, `as_datetime()` of **lubridate** package is used to convert fields with character date into **POSIXt** format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges$start_date <- as_datetime(mc3_edges$start_date)\nmc3_edges$`_last_edited_date`<- as_datetime(mc3_edges$`_last_edited_date`)\nmc3_edges$`_date_added`<- as_datetime(mc3_edges$`_date_added`)\nmc3_edges$end_date <- as_datetime(mc3_edges$end_date)\n```\n:::\n\n\nNext, `glimpse()` will be used to confirm if the process have been performed correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 75,817\nColumns: 11\n$ start_date          <dttm> 2016-10-29, 2035-06-03, 2028-11-20, 2024-09-04, 2…\n$ type                <chr> \"Event.Owns.Shareholdership\", \"Event.Owns.Sharehol…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Niklaus Oberon\", \"Pela…\n$ `_last_edited_date` <dttm> 2035-01-01, 2035-07-15, 2035-01-01, 2035-01-01, 2…\n$ `_date_added`       <dttm> 2035-01-01, 2035-07-15, 2035-01-01, 2035-01-01, 2…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Oceanus Corp…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Manual Entry\", \"Automatic Imp…\n$ source              <chr> \"Avery Inc\", \"Berger-Hayes\", \"Bowers Group\", \"Bowm…\n$ target              <chr> \"Allen, Nichols and Thompson\", \"Jensen, Morris and…\n$ key                 <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ end_date            <dttm> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n:::\n\n\n### **Changing field names in `mc3_edges`**\n\nIn the code chunk below, `rename()` of **dplyr** package is used to change the following fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- mc3_edges %>%\n  rename(\"last_edited_by\" = \"_last_edited_by\",\n         \"last_edited_date\" = \"_last_edited_date\",\n         \"date_added\" = \"_date_added\",\n         \"raw_source\" = \"_raw_source\",\n         \"algorithm\" = \"_algorithm\")\n```\n:::\n\n\n### **Splitting words in mc3_edges**\n\nFrom the screenshot below, we can see that the text in *type* field are not in a tidy manner:\n\n![](images/clipboard-3034344894.png)\n\nWe are going to tidy up the type column by creating two columns as shown below:\n\n![](images/clipboard-4077002358.png)\n\n1.  First, we find the maximum number of elements in any split:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list <- strsplit(mc3_edges$type, \"\\\\.\")\nmax_elements <- max(lengths(word_list))\n```\n:::\n\n\n2.  Then, we pad shorter splits with NA values to make them all the same length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list_padded <- lapply(word_list, \nfunction(x) c(x, rep(NA, max_elements - length(x))))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df <- do.call(rbind, word_list_padded)\ncolnames(word_df) <- paste0(\"event\", 1:max_elements)\n```\n:::\n\n\n3.  Since the output above is a matrix, we convert word_df into a tibble data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df <- as_tibble(word_df) %>%\n  select(event2, event3)\nclass(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n\n4.  Finally, we append the extracted columns back to mc3_edges tibble data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- mc3_edges %>%\n  cbind(word_df)\n```\n:::\n\n\nWe save the mc3_edges into R rds file format for future use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mc3_edges, \"data/rds/mc3_edges.rds\")\n```\n:::\n\n\n## **Wrangling and tidying nodes**\n\n### **Extracting nodes**\n\nThe code chunk below will be used to extract the *nodes* data.frame of *mc3_data* and parses it as a tibble data.frame called *mc3_nodes*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes <- as_tibble(mc3_data$nodes) %>%\n  distinct()\n```\n:::\n\n\nNext, the code chunk below is used to reveal the data structure of *mc3_nodes* tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 60,520\nColumns: 15\n$ type                <chr> \"Entity.Organization.Company\", \"Entity.Organizatio…\n$ country             <chr> \"Uziland\", \"Mawalara\", \"Uzifrica\", \"Islavaragon\", …\n$ ProductServices     <chr> \"Unknown\", \"Furniture and home accessories\", \"Food…\n$ PointOfContact      <chr> \"Rebecca Lewis\", \"Michael Lopez\", \"Steven Robertso…\n$ HeadOfOrg           <chr> \"Émilie-Susan Benoit\", \"Honoré Lemoine\", \"Jules La…\n$ founding_date       <chr> \"1954-04-24T00:00:00\", \"2009-06-12T00:00:00\", \"202…\n$ revenue             <dbl> 5994.73, 71766.67, 0.00, 0.00, 4746.67, 46566.67, …\n$ TradeDescription    <chr> \"Unknown\", \"Abbott-Gomez is a leading manufacturer…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Pelagia Alethea Mordoc…\n$ `_last_edited_date` <chr> \"2035-01-01T00:00:00\", \"2035-01-01T00:00:00\", \"203…\n$ `_date_added`       <chr> \"2035-01-01T00:00:00\", \"2035-01-01T00:00:00\", \"203…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Existing Cor…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Automatic Import\", \"Automatic…\n$ id                  <chr> \"Abbott, Mcbride and Edwards\", \"Abbott-Gomez\", \"Ab…\n$ dob                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n```\n:::\n:::\n\n\n::: callout-note\nFrom the above output:\n\n-   `founding_date`, `_last_edited_date` , `_date_added` , `dob` should be in the date data type, currently it's character data type.\n\n-   Some field names start with \"\\_\", they need to be renamed in order to avoid unnecessary coding issue in the later tasks.\n:::\n\n### **Correcting date data type in `mc3_nodes`**\n\nIn the code chunk below, `as_datetime()` of **lubridate** package is used to convert fields with character date into **POSIXt** format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes$founding_date <- as_datetime(mc3_nodes$founding_date)\nmc3_nodes$`_last_edited_date`<- as_datetime(mc3_nodes$`_last_edited_date`)\nmc3_nodes$`_date_added`<- as_datetime(mc3_nodes$`_date_added`)\nmc3_nodes$dob <- as_datetime(mc3_nodes$dob)\n```\n:::\n\n\nNext, `glimpse()` will be used to confirm if the process have been performed correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 60,520\nColumns: 15\n$ type                <chr> \"Entity.Organization.Company\", \"Entity.Organizatio…\n$ country             <chr> \"Uziland\", \"Mawalara\", \"Uzifrica\", \"Islavaragon\", …\n$ ProductServices     <chr> \"Unknown\", \"Furniture and home accessories\", \"Food…\n$ PointOfContact      <chr> \"Rebecca Lewis\", \"Michael Lopez\", \"Steven Robertso…\n$ HeadOfOrg           <chr> \"Émilie-Susan Benoit\", \"Honoré Lemoine\", \"Jules La…\n$ founding_date       <dttm> 1954-04-24, 2009-06-12, 2029-12-15, 1972-02-16, 1…\n$ revenue             <dbl> 5994.73, 71766.67, 0.00, 0.00, 4746.67, 46566.67, …\n$ TradeDescription    <chr> \"Unknown\", \"Abbott-Gomez is a leading manufacturer…\n$ `_last_edited_by`   <chr> \"Pelagia Alethea Mordoch\", \"Pelagia Alethea Mordoc…\n$ `_last_edited_date` <dttm> 2035-01-01, 2035-01-01, 2035-01-01, 2035-01-01, 2…\n$ `_date_added`       <dttm> 2035-01-01, 2035-01-01, 2035-01-01, 2035-01-01, 2…\n$ `_raw_source`       <chr> \"Existing Corporate Structure Data\", \"Existing Cor…\n$ `_algorithm`        <chr> \"Automatic Import\", \"Automatic Import\", \"Automatic…\n$ id                  <chr> \"Abbott, Mcbride and Edwards\", \"Abbott-Gomez\", \"Ab…\n$ dob                 <dttm> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n:::\n\n\n### **Changing field names in `mc3_nodes`**\n\nIn the code chunk below, `rename()` of **dplyr** package is used to change the following fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes<- mc3_nodes %>%\n  rename(\"last_edited_by\" = \"_last_edited_by\",\n         \"last_edited_date\" = \"_last_edited_date\",\n         \"date_added\" = \"_date_added\",\n         \"raw_source\" = \"_raw_source\",\n         \"algorithm\" = \"_algorithm\")\n```\n:::\n\n\n### **Splitting words in mc3_nodes**\n\nSimilarly, we can see that the text in *type* column are not in a tidy manner:\n\n![](images/clipboard-3781947034.png)\n\nWe are going to tidy up the *type* column by creating two columns as shown below:\n\n![](images/clipboard-103283567.png)\n\n1.  First, we find the maximum number of elements in any split:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list <- strsplit(mc3_nodes$type, \"\\\\.\") \nmax_elements <- max(lengths(word_list))\n```\n:::\n\n\n2.  Then, we pad shorter splits with NA values to make them all the same length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list_padded <- lapply(word_list,  \nfunction(x) c(x, rep(NA, max_elements - length(x))))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df <- do.call(rbind, word_list_padded) \ncolnames(word_df) <- paste0(\"event\", 1:max_elements)\n```\n:::\n\n\n3.  Since the output above is a matrix, we convert word_df into a tibble data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df <- as_tibble(word_df) %>%   \n  select(event2, event3) \nclass(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n\n4.  Finally, we append the extracted columns back to mc3_nodes tibble data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes <- mc3_nodes %>%   \n  cbind(word_df)\n```\n:::\n\n\nWe save the mc3_nodes into R rds file format for future use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mc3_nodes, \"data/rds/mc3_nodes.rds\")\n```\n:::\n\n\nTo read these files in future:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges <- read_rds(\"data/rds/mc3_edges.rds\")\nmc3_nodes <- read_rds(\"data/rds/mc3_nodes.rds\")\n```\n:::\n\n\n## Data Visualisations\n\n### **Task 2**\n\nWe are going to attempt Task 2:\n\n|                                                                                                                                                                                                         |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Using your visualizations, find and display examples of typical and atypical business transactions (e.g., mergers, acquisitions, etc.). Can you infer the motivations behind changes in their activity? |\n\nIdeas for question 2:\n\nfilter out companies (Company, FinancialCompany, FishingCompany, LogisticsCompany, NewsCompany)\n\n### **Task 3**\n\nNext, we are going to attempt Task 3:\n\n|                                                                                                                                                                           |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Develop a visual approach to examine inferences. Infer how the influence of a company changes through time. Can you infer ownership or influence that a network may have? |\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}